<!DOCTYPE html>
<html>
<head>
    <title>Simulación Automática con GLB</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Configuración básica
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 60, 80);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Luz
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(20, 50, 20);
        light.castShadow = true;
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));

        // Suelo
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        // Marcas de carretera (para mejor visualización)
        const roadMarkings = [];
        for (let i = -100; i <= 100; i += 10) {
            // Líneas centrales en eje X
            const lineX = new THREE.Mesh(
                new THREE.PlaneGeometry(5, 0.5),
                new THREE.MeshStandardMaterial({ color: 0xffff00 })
            );
            lineX.rotation.x = -Math.PI / 2;
            lineX.position.set(i, 0.1, 0);
            scene.add(lineX);
            
            // Líneas centrales en eje Z
            const lineZ = new THREE.Mesh(
                new THREE.PlaneGeometry(0.5, 5),
                new THREE.MeshStandardMaterial({ color: 0xffff00 })
            );
            lineZ.rotation.x = -Math.PI / 2;
            lineZ.position.set(0, 0.1, i);
            scene.add(lineZ);
        }

        // Semáforo (simple)
        const semaforo = new THREE.Mesh(
            new THREE.BoxGeometry(1, 4, 1),
            new THREE.MeshStandardMaterial({ color: 0x00ff00 })
        );
        semaforo.position.set(0, 2, -10);
        scene.add(semaforo);
        let semaforoState = "green";

        setInterval(() => {
            if (semaforoState === "green") {
                semaforo.material.color.set(0xff0000);
                semaforoState = "red";
            } else {
                semaforo.material.color.set(0x00ff00);
                semaforoState = "green";
            }
        }, 4000); // cambia cada 4 segundos

        // Variables para autos
        const cars = [];
        const carSpeed = 0.1;
        const loader = new THREE.GLTFLoader();

        function crearAuto(x, z, direccion) {
            // Modelo temporal mientras se carga el GLB
            const tempCar = new THREE.Mesh(
                new THREE.BoxGeometry(2, 1, 4),
                new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff })
            );
            tempCar.position.set(x, 0.5, z);
            
            // Orientar según la dirección
            if (direccion === "x+") tempCar.rotation.y = 0;
            if (direccion === "x-") tempCar.rotation.y = Math.PI;
            if (direccion === "z+") tempCar.rotation.y = -Math.PI / 2;
            if (direccion === "z-") tempCar.rotation.y = Math.PI / 2;
            
            scene.add(tempCar);
            cars.push({ model: tempCar, direccion, isTemp: true });

            // Intentar cargar el modelo GLB
            loader.load('models/car.glb', (gltf) => {
                const car = gltf.scene;
                car.scale.set(3.5, 3.5, 3.5);
                car.position.set(x, 0.5, z);
                
                // Misma orientación que el modelo temporal
                car.rotation.y = tempCar.rotation.y;
                
                // Reemplazar el modelo temporal
                scene.remove(tempCar);
                scene.add(car);
                
                // Actualizar la referencia en el array
                const carIndex = cars.findIndex(c => c.model === tempCar);
                if (carIndex !== -1) {
                    cars[carIndex] = { model: car, direccion, isTemp: false };
                }
            }, undefined, (error) => {
                console.error("Error al cargar el modelo GLB:", error);
            });
        }

        // Crear autos en diferentes direcciones
        crearAuto(-40, 0, "x+"); // Auto moviéndose en dirección positiva X
        crearAuto(40, 0, "x-");  // Auto moviéndose en dirección negativa X
        crearAuto(0, -40, "z+"); // Auto moviéndose en dirección positiva Z
        crearAuto(0, 40, "z-");  // Auto moviéndose en dirección negativa Z
        
        // Crear más autos para simular tráfico
        for (let i = 1; i < 5; i++) {
            crearAuto(-40 - i * 8, 0, "x+");
            crearAuto(40 + i * 8, 0, "x-");
            crearAuto(0, -40 - i * 8, "z+");
            crearAuto(0, 40 + i * 8, "z-");
        }

        // Animación
        function animate() {
            requestAnimationFrame(animate);

            cars.forEach(obj => {
                const car = obj.model;
                
                // Solo mover si el semáforo está verde o si no está cerca del semáforo
                const nearSemaforo = car.position.distanceTo(semaforo.position) < 15;
                const shouldMove = semaforoState === "green" || !nearSemaforo;
                
                if (shouldMove) {
                    if (obj.direccion === "x+") {
                        car.position.x += carSpeed;
                        if (car.position.x > 50) car.position.x = -50;
                    }
                    if (obj.direccion === "x-") {
                        car.position.x -= carSpeed;
                        if (car.position.x < -50) car.position.x = 50;
                    }
                    if (obj.direccion === "z+") {
                        car.position.z += carSpeed;
                        if (car.position.z > 50) car.position.z = -50;
                    }
                    if (obj.direccion === "z-") {
                        car.position.z -= carSpeed;
                        if (car.position.z < -50) car.position.z = 50;
                    }
                }
            });

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>